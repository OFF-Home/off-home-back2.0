'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslangUtils = require('tslang-utils');

function findNodes(root, targets, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$value = _ref.value,
      value = _ref$value === void 0 ? 'value' : _ref$value,
      _ref$children = _ref.children,
      children = _ref$children === void 0 ? 'children' : _ref$children;

  var values = [];
  var nodes = [];

  if (!root) {
    return {
      nodes: nodes,
      values: values
    };
  }

  function dfs(root) {
    if (!root) {
      return;
    }

    var index = targets.indexOf(root[value]);

    if (index > -1) {
      values[index] = root[value];
      nodes[index] = root;
    }

    if (Array.isArray(root[children]) && root[children].length > 0) {
      root[children].forEach(dfs);
    }
  }

  dfs(root);
  return {
    nodes: nodes,
    values: values
  };
}
function findPathNodes(root, targets, _temp2) {
  var _ref2 = _temp2 === void 0 ? {} : _temp2,
      _ref2$value = _ref2.value,
      value = _ref2$value === void 0 ? 'value' : _ref2$value,
      _ref2$children = _ref2.children,
      children = _ref2$children === void 0 ? 'children' : _ref2$children;

  var nodes = [];

  if (!root) {
    return nodes;
  }

  var queue = [root];
  var levelIndex = -1;

  while (queue.length > 0) {
    var levelSize = queue.length;
    levelIndex++;

    for (var i = 0; i < levelSize; i++) {
      var current = queue.shift();

      if (current[value] === targets[levelIndex]) {
        nodes.push(current);

        if (levelIndex < targets.length - 1) {
          queue.push.apply(queue, current[children] || []);
        }

        break;
      }
    }
  }

  return nodes;
}

function createPathFinder(callback) {
  return function pathFinder(root, target, _temp3) {
    var _ref3 = _temp3 === void 0 ? {} : _temp3,
        _ref3$value = _ref3.value,
        value = _ref3$value === void 0 ? 'value' : _ref3$value,
        _ref3$children = _ref3.children,
        children = _ref3$children === void 0 ? 'children' : _ref3$children;

    var track = [];
    var answer = [];

    function backtracking(root) {
      if (!root) {
        return;
      }

      track.push(root);

      if (tslangUtils.isDef(root[value]) && root[value] === target) {
        answer = callback(track, answer);
      }

      if (Array.isArray(root[children])) {
        root[children].forEach(backtracking);
      }

      track.pop();
    }

    backtracking(root);
    return answer;
  };
}

function findPath(root, target, treeNodeFields) {
  if (treeNodeFields === void 0) {
    treeNodeFields = {};
  }

  return createPathFinder(function (track) {
    return [].concat(track);
  })(root, target, treeNodeFields);
}
function findAllPaths(root, target, treeNodeFields) {
  if (treeNodeFields === void 0) {
    treeNodeFields = {};
  }

  return createPathFinder(function (track, answer) {
    return answer.concat([[].concat(track)]);
  })(root, target, treeNodeFields);
}

function levelorder(root, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$value = _ref.value,
      value = _ref$value === void 0 ? 'value' : _ref$value,
      _ref$children = _ref.children,
      children = _ref$children === void 0 ? 'children' : _ref$children;

  var ans = [];

  if (!tslangUtils.isDef(root)) {
    return ans;
  }

  var queue = [root];

  while (queue.length > 0) {
    var levelSize = queue.length;
    ans.push([]);

    for (var i = 0; i < levelSize; i++) {
      var current = queue.shift();
      ans[ans.length - 1].push(current[value]);
      var nextLevel = current[children];

      if (Array.isArray(nextLevel)) {
        queue.push.apply(queue, nextLevel);
      }
    }
  }

  return ans;
}
var bfs = levelorder;
function preorder(root, _temp2) {
  var _ref2 = _temp2 === void 0 ? {} : _temp2,
      _ref2$value = _ref2.value,
      value = _ref2$value === void 0 ? 'value' : _ref2$value,
      _ref2$children = _ref2.children,
      children = _ref2$children === void 0 ? 'children' : _ref2$children;

  var ans = [];

  if (!tslangUtils.isDef(root)) {
    return ans;
  }

  function dfs(root, ans) {
    if (!tslangUtils.isDef(root)) {
      return;
    }

    ans.push(root[value]);

    if (Array.isArray(root[children]) && root[children].length > 0) {
      root[children].forEach(function (child) {
        return dfs(child, ans);
      });
    }
  }

  dfs(root, ans);
  return ans;
}
function postorder(root, _temp3) {
  var _ref3 = _temp3 === void 0 ? {} : _temp3,
      _ref3$value = _ref3.value,
      value = _ref3$value === void 0 ? 'value' : _ref3$value,
      _ref3$children = _ref3.children,
      children = _ref3$children === void 0 ? 'children' : _ref3$children;

  var ans = [];

  if (!tslangUtils.isDef(root)) {
    return ans;
  }

  function dfs(root, ans) {
    if (!tslangUtils.isDef(root)) {
      return;
    }

    if (Array.isArray(root[children]) && root[children].length > 0) {
      root[children].forEach(function (child) {
        return dfs(child, ans);
      });
    }

    ans.push(root[value]);
  }

  dfs(root, ans);
  return ans;
}

exports.bfs = bfs;
exports.findAllPaths = findAllPaths;
exports.findNodes = findNodes;
exports.findPath = findPath;
exports.findPathNodes = findPathNodes;
exports.levelorder = levelorder;
exports.postorder = postorder;
exports.preorder = preorder;
//# sourceMappingURL=n-ary-tree.cjs.development.js.map
